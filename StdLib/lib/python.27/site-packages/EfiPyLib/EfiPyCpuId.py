#
# CpuIdLib.py
#
# Copyright (C) 2016 - 2018 efipy.core@gmail.com All rights reserved.
#
# CpuIdLib.py is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, version 2 of the License.
#
# CpuIdLib.py is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with EfiPy.  If not, see <http://www.gnu.org/licenses/>.
#

from LoLeOp.CpuId import CPUID
from LoLeOp.Mem   import Mem32
import struct as _struct


def vendor():

  return _struct.pack("III", CPUID (0).EBX, CPUID (0).EDX, CPUID (0).ECX)

def stepping_id():

  return CPUID (1).EAX.SteppingId

def model():

  a = CPUID (1).EAX

  # model_number = (a >> 4) & 0xf
  # extended_model = (a >> 16) & 0xf
  # return (extended_model << 4) + model_number

  return Mem32[a[4:7], a[16:19]]
  # return (a.ExtendedModelId << 4) + a.Model

def family():

  a = CPUID (1).EAX
  family_code = (a >> 8) & 0xf
  extended_family = (a >> 20) & 0xff
  return extended_family + family_code


def processor_type():

  a = CPUID (1).EAX
  return (a >> 12) & 0x3


def brand_id():

  a = CPUID (1).EBX
  return a.BrandIndex

EXTENDED_OFFSET = 0x80000000

def brand_string():

  a = CPUID (EXTENDED_OFFSET).EAX
  assert a >= (EXTENDED_OFFSET | 0x4), "brand string is not supported by this CPU"
  # s = ''.join([_struct.pack("IIII", *cpuid(EXTENDED_OFFSET | k)) for k in 0x2, 0x3, 0x4])
  a = CPUID (EXTENDED_OFFSET | 0x02)
  s = ''.join(_struct.pack("IIII", a.EAX, a.EBX, a.ECX, a.EDX))
  a = CPUID (EXTENDED_OFFSET | 0x03)
  s = s + ''.join(_struct.pack("IIII", a.EAX, a.EBX, a.ECX, a.EDX))
  a = CPUID (EXTENDED_OFFSET | 0x04)
  s = s + ''.join(_struct.pack("IIII", a.EAX, a.EBX, a.ECX, a.EDX))
  return s[:s.index('\0')]


def features():
  '''
  features() -> [str, str, ...]
  returns sequence of available features
  '''
  info = [CPUID (1).EAX, CPUID (1).EBX, CPUID (1).ECX, CPUID (1).EDX]

  return [key for key, reg, bit in _feat_table if info[reg] & (1 << bit)]

_feat_table = [
    ("FPU", 3, 0),
    ("VME", 3, 1),
    ("DE", 3, 2),
    ("PSE", 3, 3),
    ("TSC", 3, 4),
    ("MSR", 3, 5),
    ("PAE", 3, 6),
    ("MCE", 3, 7),
    ("CX8", 3, 8),
    ("APIC", 3, 9),
    ("SEP", 3, 11),
    ("MTRR", 3, 12),
    ("PGE", 3, 13),
    ("MCA", 3, 14),
    ("CMOV", 3, 15),
    ("PAT", 3, 16),
    ("PSE36", 3, 17),
    ("PSN", 3, 18),
    ("CLFLSH", 3, 19),
    ("DS", 3, 21),
    ("ACPI", 3, 22),
    ("MMX", 3, 23),
    ("FXSR", 3, 24),
    ("SSE", 3, 25),
    ("SSE2", 3, 26),
    ("SS", 3, 27),
    ("HTT", 3, 28),
    ("TM", 3, 29),
    ("PBE", 3, 31),
    ("SSE3", 2, 0),
    ("PCLMULDQ", 2, 1),
    ("DTES64", 2, 2),
    ("MONITOR", 2, 3),
    ("DSCPL", 2, 4),
    ("VMX", 2, 5),
    ("SMX", 2, 6),
    ("EST", 2, 7),
    ("TM2", 2, 8),
    ("SSE3", 2, 9),
    ("CNXTID", 2, 10),
    ("CX16", 2, 13),
    ("XTPR", 2, 14),
    ("PDCM", 2, 15),
    ("DCA", 2, 18),
    ("SSE4_1", 2, 19),
    ("SSE4_2", 2, 20),
    ("X2APIC", 2, 21),
    ("MOVBE", 2, 22),
    ("POPCNT", 2, 23),
    ("AES", 2, 25),
    ("XSAVE", 2, 26),
    ("OSXSAVE", 2, 27),
    ]

if __name__ == '__main__':

  cpu  = CpuIdClass()
  reg  = CpuIdReturn()

  Ieax = {0x00000000: (0x00, None),
          0x00000001: (0x00, CpuIdEax01),
          0x00000002: (0x00, CpuIdEax02),
          0x00000003: (0x00, CpuIdEax03),
          0x00000004: (0x00, CpuIdEax04),
          0x00000005: (0x00, CpuIdEax05),
          0x00000006: (0x00, CpuIdEax06),
          0x00000009: (0x00, CpuIdEax09),
          0x0000000A: (0x00, CpuIdEax0A),
          0x0000000B: (0x00, CpuIdEax0B),
          0x0000000D: (0x00, None),
          0x80000000: (0x00, CpuIdEax8x00),
          0x80000001: (0x00, CpuIdEax8x01),
          0x80000002: (0x00, CpuIdEax8x02),
          0x80000003: (0x00, CpuIdEax8x03),
          0x80000004: (0x00, CpuIdEax8x04),
          0x80000005: (0x00, CpuIdEax8x05),
          0x80000006: (0x00, CpuIdEax8x06),
          0x80000007: (0x00, CpuIdEax8x07),
          0x80000008: (0x00, CpuIdEax8x08)
         }


  for eax in sorted(Ieax):

    if Ieax[eax][1] == None:
      CpuR = EfiPy.addressof (reg)
      cpuI = reg
    else:
      class CpuIdEaxU (EfiPy.Union):
        _pack_   = 1
        _fields_ = [
          ('reg',  CpuIdRegister),
          ('CpuField', Ieax[eax][1])
        ]

      # cpuI = Ieax[eax][1]()
      cpuI = CpuIdEaxU()
      CpuR = EfiPy.addressof (cpuI)

    rax = cpu.cpuid(eax, Ieax[eax][0], CpuR)

    print "============================================"
    print "   Input      EAX      EBX      ECX      EDX"
    print "%08X %08X %08X %08X %08X" % (rax,
                                        cpuI.reg.EAX,
                                        cpuI.reg.EBX,
                                        cpuI.reg.ECX,
                                        cpuI.reg.EDX)

    print

    if Ieax[eax][1] != None:
      for field in cpuI._fields_[1][1]._fields_:
        print " %30s" % field[0], ": 0x%08X" % getattr(cpuI.CpuField, field[0])

    print
