#
# EfiPyAcpiLib.py
#
# Copyright (C) 2018 efipy.core@gmail.com All rights reserved.
#
# EfiPyAcpiLib.py is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, version 2 of the License.
#
# EfiPyAcpiLib.py is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with EfiPy.  If not, see <http://www.gnu.org/licenses/>.
#

import EfiPy
import EfiPyLib.acpi.EfiPyAcpiBase  as AcpiBase
from EfiPyLib.EfiPyHexDump          import EfiPyHexDump
import EfiPy.MdePkg.IndustryStandard.Acpi as _acpi
from EfiPy.MdePkg.IndustryStandard.Acpi10 import EFI_ACPI_DESCRIPTION_HEADER, EFI_ACPI_1_0_FIRMWARE_ACPI_CONTROL_STRUCTURE

def AcpiDump (AcpiName, FullDump = False):

  import struct

  for _signature, _address, _length in AcpiBase.AcpiTables:

    if    AcpiName in 'RSD PTR ' and _signature in 'RSD PTR ':
      print "   RSDP:Signature:         '%s'"    % struct.pack ("Q", AcpiBase.Rsdp.Signature)
      print "   RSDP:Checksum:          0x%02X"  % AcpiBase.Rsdp.Checksum
      print "   RSDP:OemId:             '%s'"    % bytearray (AcpiBase.Rsdp.OemId)
      print "   RSDP:Revision:          0x%02X"  % AcpiBase.Rsdp.Revision
      print "   RSDP:RsdtAddress:       0x%08X"  % AcpiBase.Rsdp.RsdtAddress
      print "   RSDP:Length:            0x%02X"  % AcpiBase.Rsdp.Length
      print "   RSDP:XsdtAddress:       0x%016X" % AcpiBase.Rsdp.XsdtAddress
      print "   RSDP:ExtendedChecksum:  0x%02X"  % AcpiBase.Rsdp.ExtendedChecksum

      if FullDump == True:
        _cAddress = _address
        _cLength  = _length
        _Memory = (EfiPy.CHAR8 * (_cLength)).from_address (_cAddress)
        EfiPyHexDump (2, _cAddress, _Memory, True, AcpiName)

      return

    elif    AcpiName in 'FACS' and _signature in 'FACS':

      # TODO
      print "   FACS:Signature:         '%s'"    % AcpiName
      print "   FACS:Length:            0x%02X"  % _length
      print "   FACS spec size:         0x%04X" % EfiPy.sizeof (EFI_ACPI_1_0_FIRMWARE_ACPI_CONTROL_STRUCTURE)
      if FullDump == True:
        _cAddress = _address
        _cLength  = _length
        _Memory = (EfiPy.CHAR8 * (_cLength)).from_address (_cAddress)
        EfiPyHexDump (2, _cAddress, _Memory, True, AcpiName)

      return

    elif  AcpiName in _signature:

      _Header = EFI_ACPI_DESCRIPTION_HEADER.from_address (_address)

      print "   %s:Signature:        '%s'"     % (AcpiName, struct.pack ("I", _Header.Signature))
      print "   %s:Length:           0x%08X"   % (AcpiName, _Header.Length)
      print "   %s:Revision:         0x%02X"   % (AcpiName, _Header.Revision)
      print "   %s:Checksum:         0x%02X"   % (AcpiName, _Header.Checksum)
      print "   %s:OemId:            '%s'"     % (AcpiName, bytearray (_Header.OemId))
      print "   %s:OemTableId:       '%s'"     % (AcpiName, struct.pack ("Q", _Header.OemTableId))
      print "   %s:OemRevision:      0x%08X"   % (AcpiName, _Header.OemRevision)
      print "   %s:CreatorId:        '%s'"     % (AcpiName, struct.pack ("I", _Header.CreatorId))
      print "   %s:CreatorRevision:  0x%08X"   % (AcpiName, _Header.CreatorRevision)

      if FullDump == True:
        _cAddress = _address
        _cLength  = _length
      else:
        _cAddress = _address + EfiPy.sizeof (EFI_ACPI_DESCRIPTION_HEADER)
        _cLength  = _length - EfiPy.sizeof (EFI_ACPI_DESCRIPTION_HEADER)

      _Memory = (EfiPy.CHAR8 * (_cLength)).from_address (_cAddress)
      EfiPyHexDump (2, _cAddress, _Memory, True, AcpiName)

def AcpiCheckSum (AcpiName):

  for _signature, _address, _length in AcpiBase.AcpiTables:

    if AcpiName in _signature:
      _Memory = (EfiPy.CHAR8 * _length).from_address (_address)
      return sum (bytearray (_Memory)) % 0x100
