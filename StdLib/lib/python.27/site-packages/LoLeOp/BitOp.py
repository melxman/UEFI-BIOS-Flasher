#
# BitOp.py
#
# Copyright (C) 2017 efipy.core@gmail.com All rights reserved.
#
# BitOp.py is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, version 2 of the License.
#
# BitOp.py is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with EfiPy.  If not, see <http://www.gnu.org/licenses/>.
#

import sys

MaskCache = (
              0x0000000000000000,
              0x0000000000000001,
              0x0000000000000003,
              0x0000000000000007,
              0x000000000000000F,
              0x000000000000001F,
              0x000000000000003F,
              0x000000000000007F,
              0x00000000000000FF,
              0x00000000000001FF,
              0x00000000000003FF,
              0x00000000000007FF,
              0x0000000000000FFF,
              0x0000000000001FFF,
              0x0000000000003FFF,
              0x0000000000007FFF,
              0x000000000000FFFF,
              0x000000000001FFFF,
              0x000000000003FFFF,
              0x000000000007FFFF,
              0x00000000000FFFFF,
              0x00000000001FFFFF,
              0x00000000003FFFFF,
              0x00000000007FFFFF,
              0x0000000000FFFFFF,
              0x0000000001FFFFFF,
              0x0000000003FFFFFF,
              0x0000000007FFFFFF,
              0x000000000FFFFFFF,
              0x000000001FFFFFFF,
              0x000000003FFFFFFF,
              0x000000007FFFFFFF,
              0x00000000FFFFFFFF,
              0x00000001FFFFFFFF,
              0x00000003FFFFFFFF,
              0x00000007FFFFFFFF,
              0x0000000FFFFFFFFF,
              0x0000001FFFFFFFFF,
              0x0000003FFFFFFFFF,
              0x0000007FFFFFFFFF,
              0x000000FFFFFFFFFF,
              0x000001FFFFFFFFFF,
              0x000003FFFFFFFFFF,
              0x000007FFFFFFFFFF,
              0x00000FFFFFFFFFFF,
              0x00001FFFFFFFFFFF,
              0x00003FFFFFFFFFFF,
              0x00007FFFFFFFFFFF,
              0x0000FFFFFFFFFFFF,
              0x0001FFFFFFFFFFFF,
              0x0003FFFFFFFFFFFF,
              0x0007FFFFFFFFFFFF,
              0x000FFFFFFFFFFFFF,
              0x001FFFFFFFFFFFFF,
              0x003FFFFFFFFFFFFF,
              0x007FFFFFFFFFFFFF,
              0x00FFFFFFFFFFFFFF,
              0x01FFFFFFFFFFFFFF,
              0x03FFFFFFFFFFFFFF,
              0x07FFFFFFFFFFFFFF,
              0x0FFFFFFFFFFFFFFF,
              0x1FFFFFFFFFFFFFFF,
              0x3FFFFFFFFFFFFFFF,
              0x7FFFFFFFFFFFFFFF,
              0xFFFFFFFFFFFFFFFF
            )

#
# Index: (Name, Key, Start, Width)
#
_MemCellCache = {}
_CellCascadeCache = {}

_CellExtDefault = {
    # "CellUnion": EFIPY_MSR_COMMON_Reg,
    "CellDefault": None,
    "CellArray": {},
    "CellType":  None,
    "CellBits":  None,
    "CellBase":  lambda X: X
  }

#
# Memory Operation
#
# Initial parameter:
# Name:     class name
# CellType: Cell class (default: _MemCell)
# Width:    CellType width
# MemSet:   Memory set function
# MemGet:   Memory get function
# **args:   {
#             CellExt:    reference from _MemCell
#             DictKey:    Direct item in _MemArray: default None
#             CellClass:  bit field operation class
#           }
#
class _MemArray (object):

  def __init__ (self, Name, Width = 8, **args):
    import copy
    self.__name__   = Name
    self.CellClass  = copy.deepcopy(args.get("CellClass", _MemCell))
    self.Width      = Width
    self.args       = args
    self.DictKey    = copy.deepcopy(args.get("DictKey", {}))
    self.CellExt    = copy.deepcopy(args.get("CellExt", _CellExtDefault))

  def __setattr__ (self, name, value):
    try:
      Index = self.__dict__['DictKey']
      if name in Index.keys ():
        self[Index [name][0]][Index [name][1]] = value
      else:
        object.__setattr__(self, name, value)
    except:
      object.__setattr__(self, name, value)

  def __getattr__ (self, name):
    try:
      Index = object.__getattribute__ (self, 'DictKey')
      return self[Index [name][0]][Index [name][1]]
    except:
      return object.__getattribute__ (self, name)

  # ret = Mem[0x03]
  def __getitem__ (self, Key):

    if isinstance(Key, tuple):
      try:
        return _CellCascadeCache (Key)
      except:
        ret = _CellCascade (Key, self)
        _CellCascadeCache [Key] = ret
        return ret

    try:
      BitObj = _MemCellCache[(self.__name__, Key, self.CellClass,0, self.Width)]
    except:
      self.CellExt["CellUnion"] = self.CellExt["CellArray"].get (Key, self.CellExt["CellDefault"])
      BitObj = self.CellClass(self.__name__, Key, 0, self.Width, self.Width, **self.CellExt)
      _MemCellCache[(self.__name__, Key, self.CellClass,0, self.Width)] = BitObj
      BitObj.__GetValue__()
    return BitObj

  # Mem[0x03] = 0x02
  def __setitem__ (self, Key, Value):

    BitObj = self.__getitem__ (Key)
    BitObj.__SetValue__(Value)

#
# _MemCell Operation
# Name:     class name
# Index:    Index from MemArray base
# <<--- CellClass: Cell class (default: _MemCell) --->>
# Start:    start bit in memory cell
# Width:    bit number used in this object, eg cell[3:5], Start = 3, Width = 3
# mWidth:   total bit number for _MemCell
# MemSet:   Memory set function
# MemGet:   Memory get function
# **CellExt: {
#             <<--- CellUnion:  Cell union type, eg, COMMON_REG_32BITS  --->>
#             <<--- CellType:   Cell raw data type key, eg, "Uint32"    --->>
#             <<--- CellBits:   Cell structured data key , eg "Bits"    --->>
#           }
#
class _MemCell (object):

  def __init__ (self, Name, Index, Start, Width, mWidth, **CellExt):
    # self.__name__ = Name
    object.__setattr__ (self, "__name__", Name)
    # self.Start  = Start
    object.__setattr__ (self, "Start", Start)
    # self.Width  = Width
    object.__setattr__ (self, "Width", Width)
    # self.mWidth = mWidth
    object.__setattr__ (self, "mWidth", mWidth)
    # self.Index  = Index
    object.__setattr__ (self, "Index", Index)
    # self.CellType= CellType
    # object.__setattr__ (self, "CellType", CellType)

    # self.Mask   = MaskCache[self.Width]
    object.__setattr__ (self, "Mask", MaskCache[self.Width])
    # self.CellExt= CellExt
    # import copy
    # object.__setattr__ (self, "CellExt", copy.deepcopy(CellExt))
    object.__setattr__ (self, "CellExt", CellExt)
  
  def __GetValue__ (self):
    ret = self.MemGet (self.CellExt["CellBase"](self.Index))
    return (ret >> self.Start) & self.Mask

  def __SetValue__ (self, Value):

    if self.Width == self.mWidth:
      self.MemSet (self.CellExt["CellBase"](self.Index), Value)
      return

    ret = self.MemGet (self.CellExt["CellBase"](self.Index)) & ~(self.Mask << self.Start)
    _v = ((Value & self.Mask) << self.Start) | ret
    self.MemSet (self.CellExt["CellBase"](self.Index), _v)

  #
  # output opearation
  #
  def __int__(self):
    return self.__GetValue__ ()
  __index__ = __long__ = __int__

  def __len__ (self):

    return self.Width

  def __str__ (self):
    tBitform = "0x%%0%dX (" % (self.Width >> 2)
    ret = (tBitform % int (self))
    iBitForm = '0%db' % self.Width
    ret += str (format(int(self), iBitForm)) + ', '
    return ret + "%s[0x%02X][%d:%d], %d bits)" % (
                    self.__name__,
                    self.Index,
                    self.Start,
                    self.Start + self.Width - 1,
                    self.Width)

  #
  # bit opearation
  #
  def __setitem__ (self, Key, Value):

    if isinstance (Key, (int, long)):
      Key = int (Key)
    elif isinstance (Key, tuple):
      return self.__setslice__ (Key[0], Key[1], Value)
    elif isinstance (Key, slice):
      indices = Key.indices(len(self))
      return self.__setslice__ (indices[0], indices[1], Value)
    else:
      raise NotImplemented

    Value = int (Value)

    if (Value > 1) or (Value < 0):
      raise ValueError('Bit operation is 1 or 0.')

    if Key < 0:
      Key = self.Start + self.Width + Key
    else:
      Key = self.Start + Key

    if (Key >= (self.Start + self.Width)) or (Key < self.Start):
      raise IndexError()

    Mask = ~(1 << Key)
    Base = self.MemGet (self.CellExt["CellBase"](self.Index))
    self.MemSet (self.CellExt["CellBase"](self.Index), (Base & Mask) | (Value << Key))

  #
  # return object type(self)(self, Name, Index, Start, Width, MemSet, MemGet)
  #
  def __getitem__ (self, Key):

    if isinstance (Key, (int, long)):
      Key = int (Key)
    elif isinstance (Key, tuple):
      return self.__getslice__ (Key[0], Key[1])
    elif isinstance (Key, slice):
      indices = Key.indices(len(self))
      return self.__getslice__ (indices[0], indices[1])
    else:
      raise NotImplemented

    if Key < 0:
      Key = self.Start + self.Width + Key
    else:
      Key = self.Start + Key

    if (Key >= (self.Start + self.Width)) or (Key < self.Start):
      raise IndexError()

    self.__GetValue__ ()
    try:
      ret = _MemCellCache [(self.__name__, self.Index, Key, 1)]
      return ret
    except:
      ret = type(self)(self.__name__, self.Index, Key, 1, self.mWidth, **self.CellExt)
      _MemCellCache [(self.__name__, self.Index, Key, 1)] = ret
      return ret

  def __setslice__(self, a, b, sequence):

    #
    # if b == sys.maxint: # buggy: [:] error while b != sys.maxint 
    #
    # sys.maxint is from
    #
    # // UDK2017\StdLib\Include\X64\machine\limits.h
    # #define __LONG_MAX     2147483647L // 2^31 - 1
    #
    # long
    # PyInt_GetMax(void)
    # {
    #   return LONG_MAX;
    # }
    #
    if b >= sys.maxint:
      b = self.Width - 1

    if (a < 0) or (b < 0):
      raise IndexError("%d, %d" % (a, b))

    if a < b:
      _a = self.Start + a
      _w = b - a + 1
    else: # a > b
      _a = self.Start + b
      _w = a - b + 1

    if (_a + _w) > (self.Start + self.Width):
      raise IndexError("%d, %d, %d, %d" % (a, b, self.Start, self.Width))

    _Mask = 2**_w-1
    Mask = ~(_Mask << _a)

    if (sequence > _Mask) or (sequence < 0):
      raise ValueError('Bit operation value cannot larger than 0x%x.' % _Mask)

    Base = self.MemGet (self.Index)
    self.MemSet (self.Index, (Base & Mask) | (sequence << _a))

  def __getslice__(self, a, b):

    # if b == sys.maxint: # buggy: [:] error while b != sys.maxint 
    if b >= sys.maxint:
      b = self.Width - 1
    if (a < 0) or (b < 0):
      raise IndexError("%d, %d" % (a, b))

    if a < b:
      _a = self.Start + a
      _w = b - a + 1
    else: # a > b
      _a = self.Start + b
      _w = a - b + 1

    if (_a + _w) > (self.Start + self.Width):
      raise IndexError("%d, %d, %d, %d" % (a, b, self.Start, self.Width))

    self.__GetValue__ ()
    try:
      ret = _MemCellCache [(self.__name__, self.Index, _a, _w)]
      return ret
    except:
      ret = type(self)(self.__name__, self.Index, _a, _w, self.mWidth, **self.CellExt)
      _MemCellCache [(self.__name__, self.Index, _a, _w)] = ret
      return ret

  #
  # logic operation
  # (< <= == != > >=)
  # INPUT: (self, int | obecjt.__GetValue())
  # Result: return boolean type
  #

  # a < b
  def __lt__ (self, other):
    return int (self) < int (other)

  # a <= b
  def __le__ (self, other):
    return int (self) <= int (other)

  # a == b
  def __eq__ (self, other):
    return int (self) == int (other)

  # a != b
  def __ne__ (self, other):
    return int (self) != int (other)

  # a > b
  def __gt__ (self, other):
    return int (self) > int (other)

  # a >= b
  def __ge__ (self, other):
    return int (self) >= int (other)

  #
  # unary operator
  # (+= -= *= /= //= %= **= <<= >>= |= &= ^=)
  # INPUT: (int | object)
  # Result: return to object
  #

  #
  # Due to overflower and underflower condition,
  # Remove arithmetic assignment operators for TBD
  #
  # # +=
  # def __iadd__ (self, other):
  #   self.__SetValue__ (int (self) + int (other))
  #   return self
  # 
  # # -=
  # def __isub__ (self, other):
  #   self.__SetValue__ (int (self) - int (other))
  #   return self
  # 
  # # *=
  # def __imul__ (self, other):
  #   self.__SetValue__ (int (self) * int (other))
  #   return self
  # 
  # # /=
  # def __idiv__ (self, other):
  #   self.__SetValue__ (int (self) / int (other))
  #   return self
  # 
  # # //=
  # def __ifloordiv__ (self, other):
  #   self.__SetValue__ (int (self) // int (other))
  #   return self
  # 
  # # %=
  # def __imod__ (self, other):
  #   self.__SetValue__ (int (self) % int (other))
  #   return self
  # 
  # # **=
  # def __ipow__ (self, other):
  #   self.__SetValue__ (int (self) ** int (other))
  #   return self
  # 
  # # <<=
  # def __ilshift__ (self, other):
  #   self.__SetValue__ (int (self) << int (other))
  #   return self
  # 
  # # >>=
  # def __irshift__ (self, other):
  #   self.__SetValue__ (int (self) >> int (other))
  #   return self

  # # |=
  # def __ior__ (self, other):
  #   self.__SetValue__ (int (self) | int (other))
  #   return self
  # 
  # # &=
  # def __iand__ (self, other):
  #   self.__SetValue__ (int (self) & int (other))
  #   return self
  # 
  # # ^=
  # def __ixor__ (self, other):
  #   self.__SetValue__ (int (self) ^ int (other))
  #   return self

  #
  # binary operation
  # (+ - * / // % ** << >> | & ^ ~obj -obj +obj)
  # INPUT: (self, int | obecjt.__GetValue())
  # Result: return integer
  #

  #
  # arithmetic operation
  #

  # a + b
  def __add__(self, other):
    return int (self) + int (other)
  __radd__ = __add__

  # a - b
  def __sub__(self, other):
    return int (self) - int (other)

  # b - a
  def __rsub__(self, other):
    return int (other) - int (self)

  # a * b
  def __mul__(self, other):
    return int (self) * int (other)

  # a / b
  def __div__(self, other):
    return int (self) / int (other)

  # a // b
  def __floordiv__(self, other):
    return int (self) // int (other)

  # a % b
  def __mod__(self, other):
    return int (self) % int (other)

  # a ** b
  def __pow__(self, other):
    return int (self) + int (other)

  # +a
  def __pos__(self):
    return + int(self)

  # -a
  def __neg__(self):
    return - int(self)

  #
  # bit operation
  # INPUT: (self, int | obecjt.__GetValue())
  # Result: return integer
  #

  # a & b
  def __and__(self, other):
    return int (self) & int (other)
  __rand__ = __and__

  # a | b
  def __or__(self, other):
    return int (self) | int (other)
  __ror__ = __or__

  # a ^ b
  def __xor__(self, other):
    return int (self) ^ int (other)
  __rxor__ = __xor__

  # ~a
  def __inv__(self):
    return ~ int (self)

  # a << b
  def __lshift__(self, other):
    return int (self) << int (other)

  # a >> b
  def __rshift__(self, other):
    return int (self) >> int (other)

  #
  # Type converse
  #
  def __coerce__ (self, other):
    if isinstance (other, type (self)):
      return (self.__GetValue__ (), other.__GetValue__ ())
    elif isinstance (other, (int, long)):
      return (self.__GetValue__ (), other)
    raise NotImplemented

#
# Bit Conjunction
#
class _CellCascade (object):

  def __init__ (self, Key, KeyObj, Name = None):

    self.Name = Name
    self.location = 0

    _Key = []
    for item in Key:
      if isinstance( item, int ):
        _Key.append (KeyObj[item])
      else:
        _Key.append (item)
    self.Key  = tuple (_Key)

  # iterable (This is built for each register in Key)
  def __iter__(self):
    return self

  def next(self):
    if self.location == len(self.Key):
      self.location = 0
      raise StopIteration
    value = self.Key[self.location]
    self.location += 1
    return value

  # output opearation
  def __str__ (self):
    ret = ("0x%X (" % self)
    for item in self.Key[::-1]:
      iBitForm = '0%db' % item.Width
      ret += str (format(int(item), iBitForm)) + ','

    for item in self.Key[::-1]:
      ret += " %s[0x%02X][%d:%d]," % (item.__name__,
                                      item.Index,
                                      item.Start,
                                      item.Start + item.Width - 1)
    return ret + " %d bits)" % len(self)

  def __int__(self):
    return self.__GetValue__ ()

  __index__ = __long__ = __int__

  def __len__ (self):
    ret = 0
    for item in self.Key[::]:
      ret += item.Width
    return ret

  # Value settings
  def __GetValue__ (self):
    lshift = 0
    ret = 0
    for item in self.Key:
      ret |= (int (item) << lshift)
      lshift += item.Width
    return ret

  def __SetValue__ (self, Value):
    for item in self.Key:
      item.__SetValue__ (Value & MaskCache[item.Width])
      Value = Value >> item.Width

  #
  # bit opearation
  #
  def __setitem__ (self, Key, Value):

    _Key = int (Key)
    if (_Key < 0):
      _Key += len(self)
    if (_Key >= len(self)) or (_Key < 0):
      raise IndexError()

    lshift = 0
    left = _Key
    for item in self.Key:
      lshift = item.Width
      if left < lshift:
        break
      left -= lshift

    item[left] = Value

  def __getitem__ (self, Key):

    _Key = int (Key)
    if (_Key < 0):
      _Key += len(self)
    if (_Key >= len(self)) or (_Key < 0):
      raise IndexError()

    lshift = 0
    left = _Key
    for item in self.Key:
      lshift = item.Width
      if left < lshift:
        break
      left -= lshift
    return item[left]

  #
  # __setslice__
  #
  def __setslice__(self, a, b, sequence):

    # if b == sys.maxint: # buggy: [:] error while b != sys.maxint 
    if b >= sys.maxint:
      b = self.Width - 1
    if (a < 0) or (b < 0):
      raise IndexError("%d, %d" % (a, b))

    if a < b:
      _a = a
      _w = b - a + 1
    else: # a > b
      _a = b
      _w = a - b + 1

    if (_a + _w) > len(self):
      raise IndexError("%d, %d" % (_a, _w))

    KeyList = []

    SetValue = sequence
    for item in self.Key:

      # tValue = int (item) # Confirm each memory is read from memory

      if _a >= item.Width:
        _a -= item.Width
        continue

      if _a < item.Width:

        if (_w + _a) > item.Width:
          _l = item.Width - _a
        else:
          _l = _w
        item[_a: _a + _l - 1] = SetValue & MaskCache[_l]
        SetValue = SetValue >> _l

        _a -= item.Width
        _w -= _l
        if _w <= 0:
          break
        _a = 0

  #
  # __getslice__
  #
  def __getslice__(self, a, b):

    # if b == sys.maxint: # buggy: [:] error while b != sys.maxint 
    if b >= sys.maxint:
      b = self.Width - 1
    if (a < 0) or (b < 0):
      raise IndexError("%d, %d" % (a, b))

    if a < b:
      _a = a
      _w = b - a + 1
    else: # a > b
      _a = b
      _w = a - b + 1

    if (_a + _w) > len(self):
      raise IndexError("%d, %d" % (_a, _w))

    KeyList = []

    for item in self.Key:

      # tValue = int (item) # Confirm each memory is read from memory

      if _a >= item.Width:
        _a -= item.Width
        continue

      if _a < item.Width:

        if (_w + _a) > item.Width:
          _l = item.Width - _a
        else:
          _l = _w
        KeyList.append (item[_a: _a + _l - 1])

        _a -= item.Width
        _w -= _l
        if _w <= 0:
          break
        _a = 0

    if len (KeyList) == 1:
      return KeyList[0]
    try:
      return _CellCascadeCache[tuple(KeyList)]
    except:
      ret = _CellCascade (KeyList, self)
      _CellCascadeCache [tuple(KeyList)] = ret
      return ret

  #
  # logic operation
  # (< <= == != > >=)
  # INPUT: (self, int | obecjt.__GetValue())
  # Result: return boolean type
  #

  # a < b
  def __lt__ (self, other):
    return int (self) < int (other)

  # a <= b
  def __le__ (self, other):
    return int (self) <= int (other)

  # a == b
  def __eq__ (self, other):
    return int (self) == int (other)

  # a != b
  def __ne__ (self, other):
    return int (self) != int (other)

  # a > b
  def __gt__ (self, other):
    return int (self) > int (other)

  # a >= b
  def __ge__ (self, other):
    return int (self) >= int (other)

  #
  # unary operator
  # (+= -= *= /= //= %= **= <<= >>= |= &= ^=)
  # INPUT: (int | object)
  # Result: return to object
  #

  #
  # Due to overflower and underflower condition,
  # Remove arithmetic assignment operators for TBD
  #
  # # +=
  # def __iadd__ (self, other):
  #   self.__SetValue__ (int (self) + int (other))
  #   return self
  # 
  # # -=
  # def __isub__ (self, other):
  #   self.__SetValue__ (int (self) - int (other))
  #   return self
  # 
  # # *=
  # def __imul__ (self, other):
  #   self.__SetValue__ (int (self) * int (other))
  #   return self
  # 
  # # /=
  # def __idiv__ (self, other):
  #   self.__SetValue__ (int (self) / int (other))
  #   return self
  # 
  # # //=
  # def __ifloordiv__ (self, other):
  #   self.__SetValue__ (int (self) // int (other))
  #   return self
  # 
  # # %=
  # def __imod__ (self, other):
  #   self.__SetValue__ (int (self) % int (other))
  #   return self
  # 
  # # **=
  # def __ipow__ (self, other):
  #   self.__SetValue__ (int (self) ** int (other))
  #   return self
  # 
  # # <<=
  # def __ilshift__ (self, other):
  #   self.__SetValue__ (int (self) << int (other))
  #   return self
  # 
  # # >>=
  # def __irshift__ (self, other):
  #   self.__SetValue__ (int (self) >> int (other))
  #   return self

  # # |=
  # def __ior__ (self, other):
  #   self.__SetValue__ (int (self) | int (other))
  #   return self
  # 
  # # &=
  # def __iand__ (self, other):
  #   self.__SetValue__ (int (self) & int (other))
  #   return self
  # 
  # # ^=
  # def __ixor__ (self, other):
  #   self.__SetValue__ (int (self) ^ int (other))
  #   return self

  #
  # binary operation
  # (+ - * / // % ** << >> | & ^ ~obj -obj +obj)
  # INPUT: (self, int | obecjt.__GetValue())
  # Result: return integer
  #

  #
  # arithmetic operation
  #

  # a + b
  def __add__(self, other):
    return int (self) + int (other)
  __radd__ = __add__

  # a - b
  def __sub__(self, other):
    return int (self) - int (other)

  # b - a
  def __rsub__(self, other):
    return int (other) - int (self)

  # a * b
  def __mul__(self, other):
    return int (self) * int (other)

  # a / b
  def __div__(self, other):
    return int (self) / int (other)

  # a // b
  def __floordiv__(self, other):
    return int (self) // int (other)

  # a % b
  def __mod__(self, other):
    return int (self) % int (other)

  # a ** b
  def __pow__(self, other):
    return int (self) + int (other)

  # +a
  def __pos__(self):
    return + int(self)

  # -a
  def __neg__(self):
    return - int(self)

  #
  # bit operation
  # INPUT: (self, int | obecjt.__GetValue())
  # Result: return integer
  #

  # a & b
  def __and__(self, other):
    return int (self) & int (other)
  __rand__ = __and__

  # a | b
  def __or__(self, other):
    return int (self) | int (other)
  __ror__ = __or__

  # a ^ b
  def __xor__(self, other):
    return int (self) ^ int (other)
  __rxor__ = __xor__

  # ~a
  def __inv__(self):
    return ~ int (self)

  # a << b
  def __lshift__(self, other):
    return int (self) << int (other)

  # a >> b
  def __rshift__(self, other):
    return int (self) >> int (other)

  #
  # others
  #

  # __contains__
  def __contains__(self, item):
    raise

  # is_
  def is_(self, item):
    raise

  # is_not
  def is_not(self, item):
    raise

  #
  # Type converse
  #
  def __coerce__ (self, other):
    if isinstance (other, type (self)):
      return (self.__GetValue__ (), other.__GetValue__ ())
    elif isinstance (other, (int, long)):
      return (self.__GetValue__ (), other)
    raise NotImplemented
