#!/usr/bin/python

#
# Py2Efi_util.py
#
# Copyright (C) 2017 efipy.core@gmail.com All rights reserved.
#
# Py2Efi_util.py is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, version 2 of the License.
#
# EfiPy is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with EfiPy.  If not, see <http://www.gnu.org/licenses/>.
#

import SectionDoubleP as peSection
import pefile, struct

RS_TYPE_NULL    = 0x00
RS_TYPE_SCRIPT  = 0x01
RS_TYPE_LIBRARY = 0x02
RS_TYPE_VERINFO = 0x03,
RS_TYPE_ICON    = 0x04,
RS_TYPE_USER    = 0x06,
RS_TYPE_MAX     = 0x07

ScriptSignal    = "_PY2EFI\x00"

RsFormat = "<IIII"
RsFLength = struct.calcsize (RsFormat)

class PyRs:

  def __init__ (self, src, exe_path):
    self.src      = src
    self.exe_path = exe_path
    self.rs       = []
    self.RsNum    = 0

  def append (self, Data, Rs_Type):

    # typedef struct _PY2EFI_RS {
    #   UINT32  Offset;         // Offset after last PY2EFI_RS
    #   UINT32  RsLength;       // PY2EFI_RS data length
    #   UINT32  FileLength;     // PY2EFI_RS file length
    #   UINT32  Rs_Type;        // PY2EFI_RS Type
    # } PY2EFI_RS;

    RsLength   = len (Data)
    FileLength = (RsLength + 0x0000000F) & 0xFFFFFFF0
    RsData = Data + "\x00" * (FileLength - RsLength)
    # Rs = struct.pack (RsFormat, 0x0000, RsLength, FileLength, Rs_Type)
    # Rs = (RsFormat, 0x0000, RsLength, FileLength, Rs_Type, RsData)
    Rs = (RsLength, FileLength, Rs_Type, RsData)

    self.rs.append(Rs)
    self.RsNum += 1

  def _repr (self):
    pass

  def close (self):

    RsData    = ""
    RsArray   = ""
    Offset  = 0
    for rs in self.rs:
      RsArray   += struct.pack (RsFormat, Offset, *rs[:-1])
      RsData    += rs[-1]
      Offset    += rs[1]

    RsArray   += struct.pack (RsFormat, 0, 0, 0, 0)
    RsNum     = self.RsNum + 1

    #
    # EY2EFI_RS information
    #
    # RsData      = ScriptData   + LibData
    # RsLength    = ScriptFileLength + LibFileLength
    RsCheckSum  = sum(map(ord, RsData))

    #
    # PY2EFI_SIG information
    #
    SigFormat = "<IIIIII"
    Version   = 0x00000001
    Reserved  = 0x0C0C0C0C
    SigLength = 8 + struct.calcsize (SigFormat) + struct.calcsize (RsFormat) * RsNum

    pe =  pefile.PE(self.src)
    sections = peSection.SectionDoubleP(pe)
    Data = "_PY2EFI\x00" + struct.pack (SigFormat, Version, SigLength, Reserved, RsNum, Offset, RsCheckSum % 0x100000000) + RsArray + RsData

    try:
        # Characteristics: Executable as code, Readable, Contains executable code
        pe = sections.push_back(Name=".PYTHON", Characteristics=0xD8000040, Data=Data)
        # pe = sections.push_back(Characteristics=0x60000020, Data=Data)
    except SectionDoublePError as e:
        print e
    
    # print "Information on every section after two sections have been added:"
    # print_section_info(pe)

    # pefile.print_section_info(pe)

    #
    # SIA_NAT replacement
    #
    # for section in pe.sections:
    #   if section.Name == ".data\x00\x00\x00":
    #     try:
    #       SectionData = pe.__data__[section.VirtualAddress: section.VirtualAddress+section.Misc_VirtualSize]
    #       SIA_NATIndex = SectionData.index ("SIA_NAT") + section.VirtualAddress
    #       print "find SIA_NAT signature at: 0x%08X" % SIA_NATIndex
    #       pe.set_qword_at_offset (SIA_NATIndex, pe.sections[-1].VirtualAddress - pe.OPTIONAL_HEADER.AddressOfEntryPoint)
    #     except:
    #       pass

    
    pe.write(filename=self.exe_path)

  def _del (self):
    pass
