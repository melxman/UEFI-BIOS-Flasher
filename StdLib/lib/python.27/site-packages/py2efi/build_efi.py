# Changes:
#
#    can now specify 'zipfile = None', in this case the Python module
#    library archive is appended to the exe.

# Todo:
#
# Make 'unbuffered' a per-target option

from distutils.core import Command
from distutils.spawn import spawn
from distutils.errors import *
import sys, os, imp, types, stat
import marshal
import zipfile
import sets
import tempfile
import struct
import re

from Py2Efi_util import PyRs

is_win64 = struct.calcsize("P") == 8

def _is_debug_build():
    for ext, _, _ in imp.get_suffixes():
        if ext == "_d.pyd":
            return True
    return False

is_debug_build = _is_debug_build()

if is_debug_build:
    python_dll = "python%d%d_d.dll" % sys.version_info[:2]
else:
    python_dll = "python%d%d.dll" % sys.version_info[:2]

# resource constants
RT_BITMAP=2
RT_MANIFEST=24

# Pattern for modifying the 'requestedExecutionLevel' in the manifest.  Groups
# are setup so all text *except* for the values is matched.
pat_manifest_uac = re.compile(r'(^.*<requestedExecutionLevel level=")([^"])*(" uiAccess=")([^"])*(".*$)')

# note: we cannot use the list from imp.get_suffixes() because we want
# .pyc and .pyo, independent of the optimize flag.
_py_suffixes = ['.py', '.pyo', '.pyc', '.pyw']
_c_suffixes = [_triple[0] for _triple in imp.get_suffixes()
               if _triple[2] == imp.C_EXTENSION]

def imp_find_module(name):
    # same as imp.find_module, but handles dotted names
    names = name.split('.')
    path = None
    for name in names:
        result = imp.find_module(name, path)
        path = [result[1]]
    return result

def fancy_split(str, sep=","):
    # a split which also strips whitespace from the items
    # passing a list or tuple will return it unchanged
    if str is None:
        return []
    if hasattr(str, "split"):
        return [item.strip() for item in str.split(sep)]
    return str

def ensure_unicode(text):
    # if isinstance(text, unicode):
    #     return text
    # return text.decode("mbcs")
    return text

# This loader locates extension modules relative to the library.zip
# file when an archive is used (i.e., skip_archive is not used), otherwise
# it locates extension modules relative to sys.prefix.
LOADER = """
def __load():
    import imp, os, sys
    try:
        dirname = os.path.dirname(__loader__.archive)
    except NameError:
        dirname = sys.prefix
    path = os.path.join(dirname, '%s')
    mod = imp.load_dynamic(__name__, path)
##    mod.frozen = 1
__load()
del __load
"""

# A very loosely defined "target".  We assume either a "script" or "modules"
# attribute.  Some attributes will be target specific.
class Target:
    # A custom requestedExecutionLevel for the User Access Control portion
    # of the manifest for the target. May be a string, which will be used for
    # the 'requestedExecutionLevel' portion and False for 'uiAccess', or a tuple
    # of (string, bool) which specifies both values. If specified and the
    # target's 'template' executable has no manifest (ie, python 2.5 and
    # earlier), then a default manifest is created, otherwise the manifest from
    # the template is copied then updated.
    uac_info = None

    def __init__(self, **kw):
        self.__dict__.update(kw)
        # If modules is a simple string, assume they meant list
        m = self.__dict__.get("modules")
        if m and type(m) in types.StringTypes:
            self.modules = [m]
    def get_dest_base(self):
        dest_base = getattr(self, "dest_base", None)
        if dest_base: return dest_base
        script = getattr(self, "script", None)
        if script:
            return os.path.basename(os.path.splitext(script)[0])
        modules = getattr(self, "modules", None)
        assert modules, "no script, modules or dest_base specified"
        return modules[0].split(".")[-1]

    def validate(self):
        resources = getattr(self, "bitmap_resources", []) + \
                    getattr(self, "icon_resources", [])
        for r_id, r_filename in resources:
            if type(r_id) != type(0):
                raise DistutilsOptionError, "Resource ID must be an integer"
            if not os.path.isfile(r_filename):
                raise DistutilsOptionError, "Resource filename '%s' does not exist" % r_filename

def FixupTargets(targets, default_attribute):
    if not targets:
        return targets
    ret = []
    for target_def in targets:
        if type(target_def) in types.StringTypes :
            # Create a default target object, with the string as the attribute
            target = Target(**{default_attribute: target_def})
        else:
            d = getattr(target_def, "__dict__", target_def)
            if not d.has_key(default_attribute):
                raise DistutilsOptionError, \
                      "This target class requires an attribute '%s'" % default_attribute
            target = Target(**d)
        target.validate()
        ret.append(target)
    return ret

class py2efi(Command):
    description = ""
    # List of option tuples: long name, short name (None if no short
    # name), and help string.
    user_options = [
        ('dist-dir=', 'd',
         "directory to put final built distributions in (default is dist)"),

        ("excludes=", 'e',
         "comma-separated list of modules to exclude"),
        ("ignores=", None,
         "comma-separated list of modules to ignore if they are not found"),
        ("includes=", 'i',
         "comma-separated list of modules to include"),
        ("packages=", 'p',
         "comma-separated list of packages to include"),

        ("skip-archive", None,
         "do not place Python bytecode files in an archive, put them directly in the file system"),

        ("ascii", 'a',
         "do not automatically include encodings and codecs"),

        ('custom-boot-script=', None,
         "Python file that will be run when setting up the runtime environment"),
        ]

    boolean_options = ["compressed", "ascii", "skip-archive"]

    def initialize_options (self):
        self.xref =0
        self.compressed = 0       #
        self.unbuffered = 0
        self.optimize = 0         #
        self.includes = None
        self.excludes = None
        self.ignores = None
        self.packages = None
        self.dist_dir = None
        # self.dll_excludes = None
        self.typelibs = None
        self.bundle_files = 3     #
        self.skip_archive = 0     #
        self.ascii = 0
        self.custom_boot_script = None

    def finalize_options (self):
        self.optimize = int(self.optimize)
        self.excludes = fancy_split(self.excludes)
        self.includes = fancy_split(self.includes)
        self.ignores = fancy_split(self.ignores)
        self.bundle_files = int(self.bundle_files)
        if self.bundle_files < 1 or self.bundle_files > 3:
            raise DistutilsOptionError, \
                  "bundle-files must be 1, 2, or 3, not %s" % self.bundle_files
        if is_win64 and self.bundle_files < 3:
            raise DistutilsOptionError, \
                  "bundle-files %d not yet supported on win64" % self.bundle_files
        if self.skip_archive:
            if self.compressed:
                raise DistutilsOptionError, \
                      "can't compress when skipping archive"
            if self.distribution.zipfile is None:
                raise DistutilsOptionError, \
                      "zipfile cannot be None when skipping archive"
        # includes is stronger than excludes
        for m in self.includes:
            if m in self.excludes:
                self.excludes.remove(m)
        self.packages = fancy_split(self.packages)
        self.set_undefined_options('bdist',
                                   ('dist_dir', 'dist_dir'))
        # self.dll_excludes = [x.lower() for x in fancy_split(self.dll_excludes)]

    def run(self):
        build = self.reinitialize_command('build')
        build.run()
        sys_old_path = sys.path[:]
        if build.build_platlib is not None:
            sys.path.insert(0, build.build_platlib)
        if build.build_lib is not None:
            sys.path.insert(0, build.build_lib)
        try:
            self._run()
        finally:
            sys.path = sys_old_path

    def _run(self):
        self.create_directories()
        self.plat_prepare()
        self.fixup_distribution()

        dist = self.distribution

        # all of these contain module names
        required_modules = []
        # and these contains file names
        required_files = [target.script
                          for target in dist.console]

        mf = self.create_modulefinder()

        # monkey patching the compile builtin.
        # The idea is to include the filename in the error message
        orig_compile = compile
        import __builtin__
        def my_compile(source, filename, *args):
            try:
                result = orig_compile(source, filename, *args)
            except Exception, details:
                raise DistutilsError, "compiling '%s' failed\n    %s: %s" % \
                      (filename, details.__class__.__name__, details)
            return result
        __builtin__.compile = my_compile

        print "*** searching for required modules ***"
        self.find_needed_modules(mf, required_files, required_modules)

        print "*** parsing results ***"
        py_files, extensions, builtins = self.parse_mf_results(mf)

        # if self.xref:
        #     mf.create_xref()

        dlls = []
        # self.plat_finalize(mf.modules, py_files, extensions, dlls)
        # dlls = [item for item in dlls
        #        if os.path.basename(item).lower() not in self.dll_excludes]
        # should we filter self.other_depends in the same way?

        print "*** create binaries ***"
        self.create_binaries(py_files, extensions, dlls)

        self.fix_badmodules(mf)

        if mf.any_missing():
            print "The following modules appear to be missing"
            print mf.any_missing()

    def create_modulefinder(self):
        from modulefinder import ReplacePackage
        from py2efi.mf import ModuleFinder
        ReplacePackage("_xmlplus", "xml")
        return ModuleFinder(excludes=self.excludes)

    def fix_badmodules(self, mf):
        # This dictionary maps additional builtin module names to the
        # module that creates them.
        # For example, 'wxPython.misc' creates a builtin module named
        # 'miscc'.
        builtins = {}

        # Somewhat hackish: change modulefinder's badmodules dictionary in place.
        bad = mf.badmodules
        # mf.badmodules is a dictionary mapping unfound module names
        # to another dictionary, the keys of this are the module names
        # importing the unknown module.  For the 'miscc' module
        # mentioned above, it looks like this:
        # mf.badmodules["miscc"] = { "wxPython.miscc": 1 }
        for name in mf.any_missing():
            if name in self.ignores:
                del bad[name]
                continue
            mod = builtins.get(name, None)
            if mod is not None:
                if mod in bad[name] and bad[name] == {mod: 1}:
                    del bad[name]

    def create_directories(self):
        bdist_base = self.get_finalized_command('bdist').bdist_base
        # self.bdist_dir = os.path.join(bdist_base, 'winexe')
        self.bdist_dir = os.path.join(bdist_base, 'uefi')

        collect_name = "collect-%d.%d" % sys.version_info[:2]
        self.collect_dir = os.path.abspath(os.path.join(self.bdist_dir, collect_name))
        self.mkpath(self.collect_dir)

        bundle_name = "bundle-%d.%d" % sys.version_info[:2]
        self.bundle_dir = os.path.abspath(os.path.join(self.bdist_dir, bundle_name))
        self.mkpath(self.bundle_dir)

        self.temp_dir = os.path.abspath(os.path.join(self.bdist_dir, "temp"))
        self.mkpath(self.temp_dir)

        self.dist_dir = os.path.abspath(self.dist_dir)
        self.mkpath(self.dist_dir)

        if self.distribution.zipfile is None:
            self.lib_dir = self.dist_dir
        else:
            self.lib_dir = os.path.join(self.dist_dir,
                                        os.path.dirname(self.distribution.zipfile))
        self.mkpath(self.lib_dir)

    def copy_extensions(self, extensions):
        print "*** copy extensions ***"
        # copy the extensions to the target directory
        for item in extensions:
            src = item.__file__
            if self.bundle_files > 2: # don't bundle pyds and dlls
                dst = os.path.join(self.lib_dir, (item.__pydfile__))
                self.copy_file(src, dst, preserve_mode=0)
                self.lib_files.append(dst)
            else:
                # we have to preserve the packages
                package = "\\".join(item.__name__.split(".")[:-1])
                if package:
                    dst = os.path.join(package, os.path.basename(src))
                else:
                    dst = os.path.basename(src)
                self.copy_file(src, os.path.join(self.collect_dir, dst), preserve_mode=0)
                self.compiled_files.append(dst)

    def create_binaries(self, py_files, extensions, dlls):
        dist = self.distribution

        # byte compile the python modules into the target directory
        print "*** byte compile python files ***"
        self.compiled_files = byte_compile(py_files,
                                           target_dir=self.collect_dir,
                                           optimize=self.optimize,
                                           force=0,
                                           verbose=self.verbose,
                                           dry_run=self.dry_run)

        self.lib_files = []
        self.console_efi_files = []

        self.copy_extensions(extensions)

        # create the shared zipfile containing all Python modules
        if dist.zipfile is None:
            fd, archive_name = tempfile.mkstemp()
            os.close(fd)
        else:
            archive_name = os.path.join(self.lib_dir,
                                        os.path.basename(dist.zipfile))

        arcname = self.make_lib_archive(archive_name,
                                        base_dir=self.collect_dir,
                                        files=self.compiled_files,
                                        verbose=self.verbose,
                                        dry_run=self.dry_run)
        if dist.zipfile is not None:
            self.lib_files.append(arcname)

        if self.distribution.has_data_files():
            print "*** copy data files ***"
            install_data = self.reinitialize_command('install_data')
            install_data.install_dir = self.dist_dir
            install_data.ensure_finalized()
            install_data.run()

            self.lib_files.extend(install_data.get_outputs())

        # build the executables
        for target in dist.console:
            dst = self.build_executable(target, self.get_console_template(),
                                        arcname, target.script)
            self.console_efi_files.append(dst)

        if dist.zipfile is None:
            os.unlink(arcname)
        else:
            if self.bundle_files < 3 or self.compressed:
                arcbytes = open(arcname, "rb").read()
                arcfile = open(arcname, "wb")

                if self.bundle_files < 2: # bundle pythonxy.dll also
                    print "Adding %s to %s" % (python_dll, arcname)
                    arcfile.write("<pythondll>")
                    bytes = open(os.path.join(self.bundle_dir, python_dll), "rb").read()
                    arcfile.write(struct.pack("i", len(bytes)))
                    arcfile.write(bytes) # python dll

                if self.compressed:
                    # prepend zlib.pyd also
                    zlib_file = imp.find_module("zlib")[0]
                    if zlib_file:
                        print "Adding zlib%s.pyd to %s" % (is_debug_build and "_d" or "", arcname)
                        arcfile.write("<zlib.pyd>")
                        bytes = zlib_file.read()
                        arcfile.write(struct.pack("i", len(bytes)))
                        arcfile.write(bytes) # zlib.pyd

                arcfile.write(arcbytes)

####        if self.bundle_files < 2:
####            # remove python dll from the exe_dir, since it is now bundled.
####            os.remove(os.path.join(self.exe_dir, python_dll))


    # for user convenience, let subclasses override the templates to use
    def get_console_template(self):
        # EfiPy return is_debug_build and "run_d.exe" or "run.exe"
        return is_debug_build and "Py2EfiX64_d.efi" or "Py2Efix64.efi"

    def fixup_distribution(self):
        dist = self.distribution

        # Convert our args into target objects.
        dist.console = FixupTargets(dist.console, "script")

        # make sure all targets use the same directory, this is
        # also the directory where the pythonXX.dll must reside
        paths = sets.Set()
        for target in dist.console:
            paths.add(os.path.dirname(target.get_dest_base()))

        if len(paths) > 1:
            raise DistutilsOptionError, \
                  "all targets must use the same directory: %s" % \
                  [p for p in paths]
        if paths:
            exe_dir = paths.pop() # the only element
            if os.path.isabs(exe_dir):
                raise DistutilsOptionError, \
                      "exe directory must be relative: %s" % exe_dir
            self.exe_dir = os.path.join(self.dist_dir, exe_dir)
            self.mkpath(self.exe_dir)
        else:
            # Do we allow to specify no targets?
            # We can at least build a zipfile...
            self.exe_dir = self.lib_dir

    def get_boot_script(self, boot_type):
        # return the filename of the script to use for com servers.
        thisfile = sys.modules['py2efi.build_efi'].__file__
        return os.path.join(os.path.dirname(thisfile),
                            "boot_" + boot_type + ".py")

    def build_executable(self, target, template, arcname, script, vars={}):
        # Build an executable for the target
        # template is the exe-stub to use, and arcname is the zipfile
        # containing the python modules.
        # from py2exe_util import add_resource, add_icon
        ext = os.path.splitext(template)[1]
        exe_base = target.get_dest_base()
        exe_path = os.path.join(self.dist_dir, exe_base + ext)
        # The user may specify a sub-directory for the exe - that's fine, we
        # just specify the parent directory for the .zip
        parent_levels = len(os.path.normpath(exe_base).split(os.sep))-1
        lib_leaf = self.lib_dir[len(self.dist_dir)+1:]
        relative_arcname = ((".." + os.sep) * parent_levels)
        if lib_leaf: relative_arcname += lib_leaf + os.sep
        relative_arcname += os.path.basename(arcname)

        src = os.path.join(os.path.dirname(__file__), template)
        # We want to force the creation of this file, as otherwise distutils
        # will see the earlier time of our 'template' file versus the later
        # time of our modified template file, and consider our old file OK.
        old_force = self.force
        self.force = True
        # self.copy_file(src, exe_path, preserve_mode=0)
        self.PyRs = PyRs (src, exe_path)
        self.force = old_force

        # Make sure the file is writeable...
        # EfiPy Temp # os.chmod(exe_path, stat.S_IREAD | stat.S_IWRITE)
        # try:
        #     f = open(exe_path, "a+b")
        #     f.close()
        # except IOError, why:
        #     print "WARNING: File %s could not be opened - %s" % (exe_path, why)

        # We create a list of code objects, and write it as a marshaled
        # stream.  The framework code then just exec's these in order.
        # First is our common boot script.
        # boot = self.get_boot_script("common")
        # boot_code = compile(file(boot, "U").read(),
        #                     os.path.abspath(boot), "exec")
        # code_objects = [boot_code]
        code_objects = []
        vars = self.add_versioninfo(target, exe_path)
        if vars:
          for (var_name, var_val) in vars:
            code_objects.append(
                    compile("__%s__=%r\n" % (var_name, var_val), var_name, "exec")
              )
        if self.custom_boot_script:
            code_object = compile(file(self.custom_boot_script, "U").read() + "\n",
                                  os.path.abspath(self.custom_boot_script), "exec")
            code_objects.append(code_object)
        if script:
            code_object = compile(open(script, "U").read() + "\n",
                                  os.path.basename(script), "exec")
            code_objects.append(code_object)
        code_bytes = marshal.dumps(code_objects)

        if self.distribution.zipfile is None:
            relative_arcname = ""
        si = struct.pack("iiii",
                         0x78563412, # a magic value,
                         self.optimize,
                         self.unbuffered,
                         len(code_bytes),
                         ) + relative_arcname + "\000"
        # script_base = si + code_bytes
        #   si:
        #     [Empty]
        #   code_bytes:
        #     boot C:\Python27\lib\site-packages\py2exe\boot_common.py
        #     import zipextimporter; zipextimporter.install()
        #     var_name, var_val:  [Empty]
        #     custom_boot_script: [Empty]
        #     script: Hello.py
        #     zipfile: library.zip [Empty in Windows]

        script_bytes = si + code_bytes + '\000\000'
        self.announce("add script resource, %d bytes" % len(script_bytes))
        if not self.dry_run:
            # Required, script_bytes
            # add_resource(ensure_unicode(exe_path), script_bytes, u"PYTHONSCRIPT", 1, True)
            self.PyRs.append (script_bytes, 0x01)
            if (self.distribution.zipfile is None):

              try:

                with open (arcname, "rb") as arcFp:
                  arcData = ""
                  while True:
                    chunk = arcFp.read (8192)
                    if len(chunk) > 0:
                      arcData = arcData + chunk
                    else:
                      break

                arcData = "PyMemZip\00" + arcData
                self.PyRs.append (arcData, 0x02) # It should be temp zip file
              except:
                print "open %s fail" % arcname


            # # add the pythondll as resource, and delete in self.exe_dir
            # if self.bundle_files < 2 and self.distribution.zipfile is None:
            #     # bundle pythonxy.dll
            #     dll_path = os.path.join(self.bundle_dir, python_dll)
            #     bytes = open(dll_path, "rb").read()
            #     # image, bytes, lpName, lpType

            #     print "Adding %s as resource to %s" % (python_dll, exe_path)
            #     add_resource(ensure_unicode(exe_path), bytes,
            #                  # for some reason, the 3. argument MUST BE UPPER CASE,
            #                  # otherwise the resource will not be found.
            #                  ensure_unicode(python_dll).upper(), 1, False)

            if self.compressed and self.bundle_files < 3 and self.distribution.zipfile is None:
                zlib_file = imp.find_module("zlib")[0]
                if zlib_file:
                    print "Adding zlib.pyd as resource to %s" % exe_path
                    zlib_bytes = zlib_file.read()
                    # add_resource(ensure_unicode(exe_path), zlib_bytes,
                    #              # for some reason, the 3. argument MUST BE UPPER CASE,
                    #              # otherwise the resource will not be found.
                    #              u"ZLIB.PYD", 1, False)

        # # Handle all resources specified by the target
        # bitmap_resources = getattr(target, "bitmap_resources", [])
        # for bmp_id, bmp_filename in bitmap_resources:
        #     bmp_data = open(bmp_filename, "rb").read()
        #     # skip the 14 byte bitmap header.
        #     if not self.dry_run:
        #         add_resource(ensure_unicode(exe_path), bmp_data[14:], RT_BITMAP, bmp_id, False)
        # icon_resources = getattr(target, "icon_resources", [])
        # for ico_id, ico_filename in icon_resources:
        #     if not self.dry_run:
        #         add_icon(ensure_unicode(exe_path), ensure_unicode(ico_filename), ico_id)

        # # a manifest
        # mfest, mfest_id = self.build_manifest(target, src)
        # if mfest:
        #     self.announce("add manifest, %d bytes" % len(mfest))
        #     if not self.dry_run:
        #         add_resource(ensure_unicode(exe_path), mfest, RT_MANIFEST, mfest_id, False)

        # for res_type, res_id, data in getattr(target, "other_resources", []):
        #     if not self.dry_run:
        #         if isinstance(res_type, basestring):
        #             res_type = ensure_unicode(res_type)
        #         add_resource(ensure_unicode(exe_path), data, res_type, res_id, False)

        # typelib = getattr(target, "typelib", None)
        # if typelib is not None:
        #     data = open(typelib, "rb").read()
        #     add_resource(ensure_unicode(exe_path), data, u"TYPELIB", 1, False)

        # self.add_versioninfo(target, exe_path)

        # Hm, this doesn't make sense with normal executables, which are
        # already small (around 20 kB).
        #
        # But it would make sense with static build pythons, but not
        # if the zipfile is appended to the exe - it will be too slow
        # then (although it is a wonder it works at all in this case).
        #
        # Maybe it would be faster to use the frozen modules machanism
        # instead of the zip-import?
##        if self.compressed:
##            import gc
##            gc.collect() # to close all open files!
##            os.system("upx -9 %s" % exe_path)

        # if self.distribution.zipfile is None:
        #     zip_data = open(arcname, "rb").read()
        #     open(exe_path, "a+b").write(zip_data)
        self.PyRs.close ()

        return exe_path

    def add_versioninfo(self, target, exe_path):
        # Try to build and add a versioninfo resource

        def get(name, md = self.distribution.metadata):
            # Try to get an attribute from the target, if not defined
            # there, from the distribution's metadata, or None.  Note
            # that only *some* attributes are allowed by distutils on
            # the distribution's metadata: version, description, and
            # name.
            return getattr(target, name, getattr(md, name, None))

        version = get("version")
        if version is None:
            return

        from py2efi.resources.VersionInfo import Version, RT_VERSION, VersionError
        version = Version(version,
                          file_description = get("description"),
                          comments = get("comments"),
                          company_name = get("company_name"),
                          legal_copyright = get("copyright"),
                          legal_trademarks = get("trademarks"),
                          original_filename = os.path.basename(exe_path),
                          product_name = get("name"),
                          product_version = get("product_version") or version)

        # try:
        #     bytes = version.resource_bytes()
        #     print "type (bytes):", type (bytes)
        #     print repr (bytes)
        # except VersionError, detail:
        #     self.warn("Version Info will not be included:\n  %s" % detail)
        #     return

        # from py2exe_util import add_resource
        # add_resource(ensure_unicode(exe_path), bytes, RT_VERSION, 1, False)
        return version.strings

    def get_hidden_imports(self):
        # imports done from builtin modules in C code (untrackable by py2efi)
        return {"time": ["_strptime"],
##                "datetime": ["time"],
                "cPickle": ["copy_reg"],
                "parser": ["copy_reg"],
                "codecs": ["encodings"],

                "cStringIO": ["copy_reg"],
                "_sre": ["copy", "string", "sre"],
                }

    def parse_mf_results(self, mf):
        for name, imports in self.get_hidden_imports().items():
            if name in mf.modules.keys():
                for mod in imports:
                    mf.import_hook(mod)

        tcl_src_dir = tcl_dst_dir = None
        if "Tkinter" in mf.modules.keys():
            import Tkinter
            import _tkinter
            tk = _tkinter.create()
            tcl_dir = tk.call("info", "library")
            tcl_src_dir = os.path.split(tcl_dir)[0]
            tcl_dst_dir = os.path.join(self.lib_dir, "tcl")

            self.announce("Copying TCL files from %s..." % tcl_src_dir)
            self.copy_tree(os.path.join(tcl_src_dir, "tcl%s" % _tkinter.TCL_VERSION),
                           os.path.join(tcl_dst_dir, "tcl%s" % _tkinter.TCL_VERSION))
            self.copy_tree(os.path.join(tcl_src_dir, "tk%s" % _tkinter.TK_VERSION),
                           os.path.join(tcl_dst_dir, "tk%s" % _tkinter.TK_VERSION))
            del tk, _tkinter, Tkinter

        # Retrieve modules from modulefinder
        py_files = []
        extensions = []
        builtins = []

        for item in mf.modules.values():
            # There may be __main__ modules (from mf.run_script), but
            # we don't need them in the zipfile we build.
            if item.__name__ == "__main__":
                continue
            if self.bundle_files < 3 and item.__name__ in ("pythoncom", "pywintypes"):
                # these are handled specially in zipextimporter.
                continue
            src = item.__file__
            if src:
                base, ext = os.path.splitext(src)
                suffix = ext
                if sys.platform.startswith("win") and ext in [".dll", ".pyd"] \
                   and base.endswith("_d"):
                    suffix = "_d" + ext

                if suffix in _py_suffixes:
                    py_files.append(item)
                elif suffix in _c_suffixes:
                    extensions.append(item)
                    if not self.bundle_files < 3:
                        loader = self.create_loader(item)
                        if loader:
                            py_files.append(loader)
                else:
                    raise RuntimeError \
                          ("Don't know how to handle '%s'" % repr(src))
            else:
                builtins.append(item.__name__)

        # sort on the file names, the output is nicer to read
        py_files.sort(lambda a, b: cmp(a.__file__, b.__file__))
        extensions.sort(lambda a, b: cmp(a.__file__, b.__file__))
        builtins.sort()
        return py_files, extensions, builtins

    def plat_finalize(self, modules, py_files, extensions, dlls):
        # platform specific code for final adjustments to the file
        # lists
        if sys.platform == "uefi":
          dlls = []
        else:
            raise DistutilsError, "Platform %s not yet implemented" % sys.platform

    def create_loader(self, item):
        # Hm, how to avoid needless recreation of this file?
        pathname = os.path.join(self.temp_dir, "%s.py" % item.__name__)
        if self.bundle_files > 2: # don't bundle pyds and dlls
            # all dlls are copied into the same directory, so modify
            # names to include the package name to avoid name
            # conflicts and tuck it away for future reference
            fname = item.__name__ + os.path.splitext(item.__file__)[1]
            item.__pydfile__ = fname
        else:
            fname = os.path.basename(item.__file__)
            
        # and what about dry_run?
        if self.verbose:
            print "creating python loader for extension '%s' (%s -> %s)" % (item.__name__,item.__file__,fname)

        source = LOADER % fname
        if not self.dry_run:
            open(pathname, "w").write(source)
        else:
            return None
        from modulefinder import Module
        return Module(item.__name__, pathname)

    def plat_prepare(self):
        self.includes.append("warnings") # needed by Python itself
        if not self.ascii:
            self.packages.append("encodings")
            self.includes.append("codecs")
        if self.bundle_files < 3:
            self.includes.append("zipextimporter")
            self.excludes.append("_memimporter") # builtin in run_*.exe and run_*.dll
        if self.compressed:
            self.includes.append("zlib")

        # os.path will never be found ;-)
        self.ignores.append('os.path')

        # workaround for EFI lacks of spawn interface
        self.optimize = 0
        self.compressed = 0
        self.bundle_files = 3
        self.skip_archive = 0

        # update the self.ignores list to ignore platform specific
        # modules.
        if sys.platform == "uefi":
            self.ignores += ['_emx_link',
                             'ce',
                             'nt',
                             'org.python.core',
                             'os.path',
                             'os2',
                             'os2emxpath',
                             'posix',
                             'pwd',
                             'riscos',
                             'riscosenviron',
                             'riscospath',
                             'strop',
                             'subprocess',]
            # special dlls which must be copied to the exe_dir, not the lib_dir
            # self.dlls_in_exedir = [python_dll,
            #                        "w9xpopen%s.exe" % (is_debug_build and "_d" or ""),
            #                        "msvcr71%s.dll" % (is_debug_build and "d" or "")]
            self.dlls_in_exedir = []
        else:
            raise DistutilsError, "Platform %s not yet implemented" % sys.platform

    def find_needed_modules(self, mf, files, modules):
        # feed Modulefinder with everything, and return it.
        for mod in modules:
            mf.import_hook(mod)

        for path in files:
            mf.run_script(path)

        mf.run_script(self.get_boot_script("common"))

        if self.custom_boot_script:
            mf.run_script(self.custom_boot_script)

        for mod in self.includes:
            if mod[-2:] == '.*':
                mf.import_hook(mod[:-2], None, ['*'])
            else:
                mf.import_hook(mod)

        for f in self.packages:
            def visit(arg, dirname, names):
                if '__init__.py' in names:
                    arg.append(dirname)

            # Try to find the package using ModuleFinders's method to
            # allow for modulefinder.AddPackagePath interactions
            mf.import_hook(f)

            # If modulefinder has seen a reference to the package, then
            # we prefer to believe that (imp_find_module doesn't seem to locate
            # sub-packages)
            if f in mf.modules:
                module = mf.modules[f]
                if module.__path__ is None:
                    # it's a module, not a package, so paths contains just the
                    # file entry
                    paths = [module.__file__]
                else:
                    # it is a package because __path__ is available.  __path__
                    # is actually a list of paths that are searched to import
                    # sub-modules and sub-packages
                    paths = module.__path__
            else:
                # Find path of package
                try:
                    paths = [imp_find_module(f)[1]]
                except ImportError:
                    self.warn("No package named %s" % f)
                    continue

            packages = []
            for path in paths:
                # walk the path to find subdirs containing __init__.py files
                os.path.walk(path, visit, packages)

                # scan the results (directory of __init__.py files)
                # first trim the path (of the head package),
                # then convert directory name in package name,
                # finally push into modulefinder.
                for p in packages:
                    if p.startswith(path):
                        package = f + '.' + p[len(path)+1:].replace('\\', '.')
                        mf.import_hook(package, None, ["*"])

        return mf

    def make_lib_archive(self, zip_filename, base_dir, files,
                         verbose=0, dry_run=0):
        from distutils.dir_util import mkpath
        if not self.skip_archive:
            # Like distutils "make_archive", but we can specify the files
            # to include, and the compression to use - default is
            # ZIP_STORED to keep the runtime performance up.  Also, we
            # don't append '.zip' to the filename.
            mkpath(os.path.dirname(zip_filename), dry_run=dry_run)

            if self.compressed:
                compression = zipfile.ZIP_DEFLATED
            else:
                compression = zipfile.ZIP_STORED

            if not dry_run:
                z = zipfile.ZipFile(zip_filename, "w",
                                    compression=compression)
                for f in files:
                    z.write(os.path.join(base_dir, f), f)
                z.close()

            return zip_filename
        else:
            # Don't really produce an archive, just copy the files.
            from distutils.file_util import copy_file

            destFolder = os.path.dirname(zip_filename)

            for f in files:
                d = os.path.dirname(f)
                if d:
                    mkpath(os.path.join(destFolder, d), verbose=verbose, dry_run=dry_run)
                copy_file(
                          os.path.join(base_dir, f),
                          os.path.join(destFolder, f),
                          preserve_mode=0,
                          verbose=verbose,
                          dry_run=dry_run
                         )
            return '.'


################################################################

def byte_compile(py_files, optimize=0, force=0,
                 target_dir=None, verbose=1, dry_run=0,
                 direct=None):

    if direct is None:
        direct = (__debug__ and optimize == 0)

    # "Indirect" byte-compilation: write a temporary script and then
    # run it with the appropriate flags.
    if not direct:
        from tempfile import mktemp
        from distutils.util import execute
        script_name = mktemp(".py")
        if verbose:
            print "writing byte-compilation script '%s'" % script_name
        if not dry_run:
            script = open(script_name, "w")
            script.write("""\
from py2efi.build_efi import byte_compile
from modulefinder import Module
files = [
""")

            for f in py_files:
                script.write("Module(%s, %s, %s),\n" % \
                (`f.__name__`, `f.__file__`, `f.__path__`))
            script.write("]\n")
            script.write("""
byte_compile(files, optimize=%s, force=%s,
             target_dir=%s,
             verbose=%s, dry_run=0,
             direct=1)
""" % (`optimize`, `force`, `target_dir`, `verbose`))

            script.close()

        cmd = [sys.executable, script_name]
        if optimize == 1:
            cmd.insert(1, "-O")
        elif optimize == 2:
            cmd.insert(1, "-OO")
        spawn(cmd, verbose=verbose, dry_run=dry_run)
        execute(os.remove, (script_name,), "removing %s" % script_name,
                verbose=verbose, dry_run=dry_run)


    else:
        from py_compile import compile
        from distutils.dir_util import mkpath
        from distutils.dep_util import newer
        from distutils.file_util import copy_file

        for file in py_files:
            # Terminology from the py_compile module:
            #   cfile - byte-compiled file
            #   dfile - purported source filename (same as 'file' by default)
            cfile = file.__name__.replace('.', '\\')

            if file.__path__:
                dfile = cfile + '\\__init__.py' + (__debug__ and 'c' or 'o')
            else:
                dfile = cfile + '.py' + (__debug__ and 'c' or 'o')
            if target_dir:
                cfile = os.path.join(target_dir, dfile)

            if force or newer(file.__file__, cfile):
                if verbose:
                    print "byte-compiling %s to %s" % (file.__file__, dfile)
                if not dry_run:
                    mkpath(os.path.dirname(cfile))
                    suffix = os.path.splitext(file.__file__)[1]
                    if suffix in (".py", ".pyw"):
                        _f = file.__file__.replace("/", "\\")
                        #compile(file.__file__, cfile, dfile)
                        compile(_f, cfile, dfile)
                    elif suffix in _py_suffixes:
                        # Minor problem: This will happily copy a file
                        # <mod>.pyo to <mod>.pyc or <mod>.pyc to
                        # <mod>.pyo, but it does seem to work.
                        copy_file(file.__file__, cfile, preserve_mode=0)
                    else:
                        raise RuntimeError \
                              ("Don't know how to handle %r" % file.__file__)
            else:
                if verbose:
                    print "skipping byte-compilation of %s to %s" % \
                          (file.__file__, dfile)
    compiled_files = []
    for file in py_files:
        cfile = file.__name__.replace('.', '\\')

        if file.__path__:
            dfile = cfile + '\\__init__.py' + (optimize and 'o' or 'c')
        else:
            dfile = cfile + '.py' + (optimize and 'o' or 'c')
        compiled_files.append(dfile)
    return compiled_files

# byte_compile()
